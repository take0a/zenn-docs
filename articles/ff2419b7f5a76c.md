---
title: "Golangã§sqlxã‚’ä½¿ã†"
emoji: "ğŸ¹"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["golang", "sqlx", "sql", "database"]
published: false
publication_name: "robon"
---

# ã¯ã˜ã‚ã«

Golangã§ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒŠãƒ«ãƒ»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãªã‚‰ã€`database/sql`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãŠä¸–è©±ã«ãªã‚‹ã®ã§ã‚ã‚‹ã€‚ä¾‹ãˆã°ã€ã“ã‚“ãªæ„Ÿã˜ã§ã€`Insert` `Select` `Delete` ãŒã§ãã‚‹ã€‚

```go: sql/main.go
package main

import (
	"database/sql"
	"log"
	"os"

	_ "github.com/lib/pq"
)

// Customer ã¯ã€é¡§å®¢
type Customer struct {
	CustomerID int
	Name       string
	Address    string
}

// CustomerKey ã¯ã€é¡§å®¢ã®ã‚­ãƒ¼
type CustomerKey struct {
	CustomerID int
}

func main() {
	dsn := os.Getenv("DSN")
	db, err := sql.Open("postgres", dsn)
	if err != nil {
		log.Printf("sql.Open error %s", err)
	}

	key := CustomerKey{1}
	src := Customer{key.CustomerID, "Shohei Otani", "Los Angeles Angels"}

	_, err = db.Exec(`
		INSERT INTO CUSTOMER (
			CUSTOMER_ID, NAME, ADDRESS
		) VALUES (
			$1, $2, $3)`,
		src.CustomerID,
		src.Name,
		src.Address,
	)
	if err != nil {
		log.Printf("db.Exec error %s", err)
	}

	dst := Customer{}
	err = db.QueryRow(`
		SELECT 
			CUSTOMER_ID, NAME, ADDRESS
		FROM CUSTOMER 
		WHERE CUSTOMER_ID = $1`,
		key.CustomerID,
	).Scan(
		&dst.CustomerID,
		&dst.Name,
		&dst.Address,
	)
	if err != nil {
		log.Printf("db.QueryRow error %s", err)
	}
	log.Printf("\nsrc = %#v\ndst = %#v\n", src, dst)

	_, err = db.Exec(`
		DELETE FROM CUSTOMER
		WHERE CUSTOMER_ID = $1`,
		key.CustomerID,
	)
	if err != nil {
		log.Printf("db.Exec error %s", err)
	}
}
```

ã“ã‚Œã¯ã“ã‚Œã§è‰¯ã„ã®ã ã‘ã‚Œã©ã‚‚ã€ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚«ãƒ©ãƒ ã¯ã€æ„å‘³çš„ã«ã‚‚æ¦‚å¿µçš„ã«ã‚‚ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«çš„ã«ã‚‚å…±é€šã™ã‚‹éƒ¨åˆ†ãŒã‚ã‚‹ã‹ã‚‰åŒã˜ãƒ†ãƒ¼ãƒ–ãƒ«ã«é…ç½®ã•ã‚Œã¦ã„ã‚‹ã®ã§ã‚ã£ã¦ã€ãã‚Œã‚’æ‰±ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ å´ã§ã‚‚ã²ã¨å¡Šã¨ã—ã¦æ‰±ã„ãŸã„ã‚‚ã®ã§ã‚ã‚‹ã€‚ä¸Šã®å ´åˆã¯ã€Golangã®æ§‹é€ ä½“ã«ã—ã¦ã„ã‚‹ã€‚

ã“ã‚Œã‚‰ã®ã‚«ãƒ©ãƒ ã®å€¤ã‚’SQLã‚’ä»‹ã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨å…¥å‡ºåŠ›ã™ã‚‹ã®ã§ã‚ã‚‹ãŒã€`database/sql`ã®å ´åˆã€ä¸Šã®ã‚ˆã†ã«ã€`Exec`ã®å¼•æ•°ã‚‚`Scan`ã®å¼•æ•°ã‚‚é …ç›®æ¯ã«æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ã“ã†ã„ã†å ´åˆã‚‚ã‚ã‚‹ã®ã ã‚ã†ã‹ã‚‰ã€ã“ã†ã„ã†æŒ‡å®šã‚‚ã§ãã‚‹ã‚ˆã†ã«ã™ã¹ããªã®ã ã‚ã†ãŒã€æ§‹é€ ä½“ã‚’ãƒãƒ«ã£ã¨æŒ‡å®šã§ãã‚‹ã‚ˆã†ã«ã‚‚ã§ããªã„ã‚‚ã®ã ã‚ã†ã‹ã€‚

ã¾ãŸã€ä»Šå›ã¯ã€Postgresã‚’ä½¿ã£ãŸã®ã§ã€SQLæ–‡ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã« `$1` `$2` `$3` ãªã©ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã‚ã‚‹ãŒã€ã“ã‚Œã‚’MySQLã ã£ãŸã‚‰ `?` ã«ã—ã¦ã­ã€‚ã¨ã‹ã€Oracleã ã£ãŸã‚‰`:col`ã«ã—ã¦ã­ã€‚ã¨ã„ã†ã®ã‚‚ã€ã†ï½ã‚“ã€‚ã¨ã„ã†æ„Ÿã˜ã§ã‚ã‚‹ã€‚

# sqlx

sqlx ã¨ã„ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã‚ã›ã¦é ‚ãã¨ã€ã“ã‚Œã‚‰ã®æ®‹å¿µãªã¨ã“ã‚ãŒè§£æ¶ˆã•ã‚Œã‚‹ã®ã§ã‚ã‚‹ã€‚ã—ã‹ã‚‚ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç´”ç²‹ãªæ‹¡å¼µã«ãªã£ã¦ã„ã‚‹ã®ã‚‚ç´ æ™´ã‚‰ã—ã„ã€‚

https://github.com/jmoiron/sqlx

## æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ‹¡å¼µã¨ã¯

sqlx ã§ã¯ã€`database/sql` ã® `DB` `Conn` `Tx` `Stmt` ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«æ‹¡å¼µã—ã¦ã„ã‚‹ã€‚

```go: github.com/jmoiron/sqlx/blob/master/sqlx.go(æŠœç²‹)
type DB struct {
	*sql.DB
	driverName string
	unsafe     bool
	Mapper     *reflectx.Mapper
}

type Conn struct {
	*sql.Conn
	driverName string
	unsafe     bool
	Mapper     *reflectx.Mapper
}

type Tx struct {
	*sql.Tx
	driverName string
	unsafe     bool
	Mapper     *reflectx.Mapper
}

type Stmt struct {
	*sql.Stmt
	unsafe bool
	Mapper *reflectx.Mapper
}
```

ã¤ã¾ã‚Šã€`sqlx.DB` ã¯ã€`sql.DB` ã‚’åŸ‹ã‚è¾¼ã‚“ã§ã„ã‚‹ãŸã‚ã€ä¸Šæ›¸ãã§ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å†å®šç¾©ã—ã¦ã„ãªã„é™ã‚Šã€`sql.DB` ã§å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ãŒå‹•ä½œã™ã‚‹ã€‚`Conn` `Tx` `Stmt` ã‚‚åŒã˜ã§ã‚ã‚‹ã€‚

ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ `driverName` ã¯ã€ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®æ–¹è¨€ã«å¯¾å¿œã™ã‚‹ãŸã‚ã« `DB` ã‹ã‚‰ãã‚Œãã‚Œã«å¼•ãç¶™ãŒã‚Œã‚‹ã€‚ã¾ãŸã€`unsafe`ã¨`Mapper`ã¯ã€æ§‹é€ ä½“ã‚¿ã‚°ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ä»•çµ„ã¿ã®ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚`reflextx` ã¯ã€sqlx ã«å«ã¾ã‚Œã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã€ã“ã‚Œã¯ã“ã‚Œã§èˆˆå‘³æ·±ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã‚ã‚‹ãŒã€ä»Šå›ã®è¨˜äº‹ã§ã¯èª¬æ˜ã—ãªã„ã€‚

æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ‹¡å¼µã§ã‚ã‚‹ã‹ã‚‰ã€ç½®ãæ›ãˆã‚‹ã“ã¨è‡ªä½“ã¯ã€éå¸¸ã«ç°¡å˜ã§ã‚ã‚‹ã€‚

```go: sqlx1/main.go
package main

import (
	"log"
	"os"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

// Customer ã¯ã€é¡§å®¢
type Customer struct {
	CustomerID int
	Name       string
	Address    string
}

// CustomerKey ã¯ã€é¡§å®¢ã®ã‚­ãƒ¼
type CustomerKey struct {
	CustomerID int
}

func main() {
	dsn := os.Getenv("DSN")
	db, err := sqlx.Open("postgres", dsn)
	if err != nil {
		log.Printf("sql.Open error %s", err)
	}

	key := CustomerKey{1}
	src := Customer{key.CustomerID, "Shohei Otani", "Los Angeles Angels"}

	_, err = db.Exec(`
		INSERT INTO CUSTOMER (
			CUSTOMER_ID, NAME, ADDRESS
		) VALUES (
			$1, $2, $3)`,
		src.CustomerID,
		src.Name,
		src.Address,
	)
	if err != nil {
		log.Printf("db.Exec error %s", err)
	}

	dst := Customer{}
	err = db.QueryRow(`
		SELECT 
			CUSTOMER_ID, NAME, ADDRESS
		FROM CUSTOMER 
		WHERE CUSTOMER_ID = $1`,
		key.CustomerID,
	).Scan(
		&dst.CustomerID,
		&dst.Name,
		&dst.Address,
	)
	if err != nil {
		log.Printf("db.QueryRow error %s", err)
	}
	log.Printf("\nsrc = %#v\ndst = %#v\n", src, dst)

	_, err = db.Exec(`
		DELETE FROM CUSTOMER
		WHERE CUSTOMER_ID = $1`,
		key.CustomerID,
	)
	if err != nil {
		log.Printf("db.Exec error %s", err)
	}
}
```

é–“é•ã„æ¢ã—ã®è§£ç­”ã¯ã€ä»¥ä¸‹ã®ï¼’ã‹æ‰€ã§ã‚ã‚‹ã€‚

```diff go: diff sql/main.go sqlx1/main.go
4d3
<       "database/sql"
7a7
>       "github.com/jmoiron/sqlx"
25c25
<       db, err := sql.Open("postgres", dsn)
---
>       db, err := sqlx.Open("postgres", dsn)
```

ã“ã®ã‚ˆã†ã« sqlx ã‚’ä½¿ç”¨ã—ã¦ã‚‚ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦ä½œæˆã•ã‚ŒãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®æ›¸ãæ›ãˆã¯å¿…é ˆã§ã¯ãªã„ã€‚ï¼ˆå‹åã‚„é–¢æ•°åãªã©ã¯ `sql` ã‹ã‚‰ `sqlx` ã«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã®ç½®æ›ãŒå¿…è¦ã§ã¯ã‚ã‚‹ï¼‰

## Exec ã¨ Scan

ã•ã¦ã€æœ€åˆã«æèµ·ã—ãŸèª²é¡Œã¯ã€ä»¥ä¸‹ã®ï¼“ç‚¹ã ã£ãŸã€‚
- Exec ãªã©ã§å…¥åŠ›ã¨ã—ã¦æ§‹é€ ä½“ã‚’æŒ‡å®šã—ãŸã„ã€‚
- Scan ãªã©ã§å‡ºåŠ›ã¨ã—ã¦æ§‹é€ ä½“ã‚’æŒ‡å®šã—ãŸã„ã€‚
- ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®æ–¹è¨€ã‚’æ„è­˜ã—ãŸããªã„ã€‚

sqlx ã§ã¯ã€`NamedExec` ã¨ `StructScan` ã‚’ä½¿ç”¨ã—ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ã€‚

```go: sqlx2/main.go
package main

import (
	"log"
	"os"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

// Customer ã¯ã€é¡§å®¢
type Customer struct {
	CustomerID int    `db:"customer_id"`
	Name       string `db:"name"`
	Address    string `db:"address"`
}

// CustomerKey ã¯ã€é¡§å®¢ã®ã‚­ãƒ¼
type CustomerKey struct {
	CustomerID int `db:"customer_id"`
}

func main() {
	dsn := os.Getenv("DSN")
	db, err := sqlx.Open("postgres", dsn)
	if err != nil {
		log.Printf("sql.Open error %s", err)
	}

	key := CustomerKey{1}
	src := Customer{key.CustomerID, "Shohei Otani", "Los Angeles Angels"}

	_, err = db.NamedExec(`
		INSERT INTO CUSTOMER (
			CUSTOMER_ID, NAME, ADDRESS
		) VALUES (
			:customer_id, :name, :address)`,
		src,
	)
	if err != nil {
		log.Printf("db.Exec error %s", err)
	}

	dst := Customer{}
	err = db.QueryRowx(`
		SELECT 
			CUSTOMER_ID, NAME, ADDRESS
		FROM CUSTOMER 
		WHERE CUSTOMER_ID = $1`,
		key.CustomerID,
	).StructScan(
		&dst,
	)
	if err != nil {
		log.Printf("db.QueryRow error %s", err)
	}
	log.Printf("\nsrc = %#v\ndst = %#v\n", src, dst)

	_, err = db.NamedExec(`
		DELETE FROM CUSTOMER
		WHERE CUSTOMER_ID = :customer_id`,
		key,
	)
	if err != nil {
		log.Printf("db.Exec error %s", err)
	}
}
```

å…ˆç¨‹ã¨ã®é•ã„ã¯ã€`NamedExec` `StructScan` ã§ã®æ§‹é€ ä½“ã®ä½¿ç”¨ã«åŠ ãˆã¦ã€æ§‹é€ ä½“ã« `db`ã‚¿ã‚°ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ç®‡æ‰€ã¨SQLæ–‡ä¸­ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã§ã‚ã‚‹ã€‚

```diff go: diff sqlx1/main.go sqlx2/main.go
13,15c13,15
<       CustomerID int
<       Name       string
<       Address    string
---
>       CustomerID int    `db:"customer_id"`
>       Name       string `db:"name"`
>       Address    string `db:"address"`
20c20
<       CustomerID int
---
>       CustomerID int `db:"customer_id"`
33c33
<       _, err = db.Exec(`
---
>       _, err = db.NamedExec(`
37,40c37,38
<                       $1, $2, $3)`,
<               src.CustomerID,
<               src.Name,
<               src.Address,
---
>                       :customer_id, :name, :address)`,
>               src,
47c45
<       err = db.QueryRow(`
---
>       err = db.QueryRowx(`
53,56c51,52
<       ).Scan(
<               &dst.CustomerID,
<               &dst.Name,
<               &dst.Address,
---
>       ).StructScan(
>               &dst,
63c59
<       _, err = db.Exec(`
---
>       _, err = db.NamedExec(`
65,66c61,62
<               WHERE CUSTOMER_ID = $1`,
<               key.CustomerID,
---
>               WHERE CUSTOMER_ID = :customer_id`,
>               key,
```

## æœ€å¾Œã®ãƒ”ãƒ¼ã‚¹

ã¾ãã€ã“ã‚Œã§è‰¯ã„ã‹ãªã¨æ€ã£ãŸã®ã ãŒã€`QueryRowx` ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ãŒæ®‹ã£ã¦ã„ã‚‹ã€‚`NamedQuery` ã¯ã‚ã‚‹ã®ã ãŒ `NamedQueryRow` ã¯ãªã„â€¦

ä»Šå›ã¯ã€`BindNamed` ã‚’ä½¿ç”¨ã—ã¦ã‚ªãƒªã‚¸ãƒŠãƒ«ã¨ã»ã¼åŒã˜å‹•ãã«ãªã‚‹ã‚ˆã†ã«ã—ãŸã€‚

```go: sqlx3/main.go
package main

import (
	"log"
	"os"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

// Customer ã¯ã€é¡§å®¢
type Customer struct {
	CustomerID int    `db:"customer_id"`
	Name       string `db:"name"`
	Address    string `db:"address"`
}

// CustomerKey ã¯ã€é¡§å®¢ã®ã‚­ãƒ¼
type CustomerKey struct {
	CustomerID int `db:"customer_id"`
}

func main() {
	dsn := os.Getenv("DSN")
	db, err := sqlx.Open("postgres", dsn)
	if err != nil {
		log.Printf("sql.Open error %s", err)
	}

	key := CustomerKey{1}
	src := Customer{key.CustomerID, "Shohei Otani", "Los Angeles Angels"}

	_, err = db.NamedExec(`
		INSERT INTO CUSTOMER (
			CUSTOMER_ID, NAME, ADDRESS
		) VALUES (
			:customer_id, :name, :address)`,
		src,
	)
	if err != nil {
		log.Printf("db.Exec error %s", err)
	}

	dst := Customer{}
	query, args, err := db.BindNamed(`
		SELECT 
			CUSTOMER_ID, NAME, ADDRESS
		FROM CUSTOMER 
		WHERE CUSTOMER_ID = :customer_id`,
		key,
	)
	if err != nil {
		log.Printf("db.BindNamed error %s", err)
	}
	err = db.QueryRowx(query,
		args...,
	).StructScan(
		&dst,
	)
	if err != nil {
		log.Printf("db.QueryRow error %s", err)
	}
	log.Printf("\nsrc = %#v\ndst = %#v\n", src, dst)

	_, err = db.NamedExec(`
		DELETE FROM CUSTOMER
		WHERE CUSTOMER_ID = :customer_id`,
		key,
	)
	if err != nil {
		log.Printf("db.Exec error %s", err)
	}
}
```

é•ã„ã¯ã€ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã‚ã‚‹ã€‚

```diff go: diff sqlx2/main.go sqlx3/main.go
45c45
<       err = db.QueryRowx(`
---
>       query, args, err := db.BindNamed(`
49,50c49,56
<               WHERE CUSTOMER_ID = $1`,
<               key.CustomerID,
---
>               WHERE CUSTOMER_ID = :customer_id`,
>               key,
>       )
>       if err != nil {
>               log.Printf("db.BindNamed error %s", err)
>       }
>       err = db.QueryRowx(query,
>               args...,
```

# ãŠã‚ã‚Šã«

sqlx ã¯ã€éå¸¸ã«ç°¡æ½”ã«å•é¡Œã‚’è§£æ±ºã—ã¦ãã‚ŒãŸã€‚ã¾ãŸã€sqlx è‡ªä½“ã‚‚éå¸¸ã«ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«æ›¸ã‹ã‚Œã¦ã„ã¦ã€ä¸­èº«ã‚’èª­ã‚€ã“ã¨ã§å‹‰å¼·ã«ãªã£ãŸã€‚

ä»Šå›ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ã€è¨˜äº‹ä¸­ã®ã‚‚ã®ãŒã»ã¼å…¨ã¦ã§ã‚ã‚‹ãŒã€ä»¥ä¸‹ã«ã‚‚ã‚ã‚‹ã€‚

https://github.com/take0a/go-sqlx-sample
